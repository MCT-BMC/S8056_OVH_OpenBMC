From 5c2c81daf7abfe2fe5d21e073d5906c880dbe799 Mon Sep 17 00:00:00 2001
From: Wayne Tung <Wayne_Tung@wiwynn.com>
Date: Mon, 4 Jan 2021 16:52:58 +0800
Subject: [PATCH] Get fru with fixed size in config

---
 include/FruUtils.hpp |   3 +-
 src/FruDevice.cpp    |  71 ++-----------------------
 src/FruUtils.cpp     | 123 +++----------------------------------------
 3 files changed, 13 insertions(+), 184 deletions(-)

diff --git a/include/FruUtils.hpp b/include/FruUtils.hpp
index 27dbc13..b1ef0cd 100644
--- a/include/FruUtils.hpp
+++ b/include/FruUtils.hpp
@@ -142,7 +142,8 @@ ssize_t getFieldLength(uint8_t fruFieldTypeLenValue);
 /// \return the FRU contents from the file
 std::vector<uint8_t> readFRUContents(int flag, int file, uint16_t address,
                                      ReadBlockFunc readBlock,
-                                     const std::string& errorHelp);
+                                     const std::string& errorHelp,
+                                     const size_t size = 0);
 
 /// \brief Validate an IPMI FRU common header
 /// \param blockData the bytes comprising the common header
diff --git a/src/FruDevice.cpp b/src/FruDevice.cpp
index b6fffce..bdfbd28 100644
--- a/src/FruDevice.cpp
+++ b/src/FruDevice.cpp
@@ -139,16 +139,6 @@ static int64_t readFromEeprom(int flag __attribute__((unused)), int fd,
     return read(fd, buf, len);
 }
 
-static int busStrToInt(const std::string& busName)
-{
-    auto findBus = busName.rfind("-");
-    if (findBus == std::string::npos)
-    {
-        return -1;
-    }
-    return std::stoi(busName.substr(findBus + 1));
-}
-
 static int getRootBus(size_t bus)
 {
     auto ec = std::error_code();
@@ -273,7 +263,7 @@ static int64_t readBlockData(int flag, int file, uint16_t address,
 
 // TODO: This code is very similar to the non-eeprom version and can be merged
 // with some tweaks.
-static std::vector<uint8_t> processEeprom(int bus, int address)
+static std::vector<uint8_t> processEeprom(int bus, int address, size_t size = 0)
 {
     auto path = getEepromPath(bus, address);
 
@@ -286,8 +276,9 @@ static std::vector<uint8_t> processEeprom(int bus, int address)
 
     std::string errorMessage = "eeprom at " + std::to_string(bus) +
                                " address " + std::to_string(address);
-    std::vector<uint8_t> device = readFRUContents(
-        0, file, static_cast<uint16_t>(address), readFromEeprom, errorMessage);
+    std::vector<uint8_t> device =
+        readFRUContents(0, file, static_cast<uint16_t>(address), readFromEeprom,
+                        errorMessage, size);
 
     close(file);
     return device;
@@ -615,16 +606,13 @@ static void getFruDevices(BusMap& busmap)
             std::vector<uint8_t> device;
             if (hasEepromFile(bus, addressInt) == true)
             {
-                device = processEeprom(bus, addressInt);
+                device = processEeprom(bus, addressInt, size);
             }
             else
             {
                 continue;
             }
 
-            // Appending 0xFF makes size is equal to fru size.
-            device.insert(device.end(), size - device.size(), 0xFF);
-
             struct DeviceInfo deviceInfo = {index, size, readOnly};
             if (busmap.find(bus) == busmap.end())
             {
@@ -1376,55 +1364,6 @@ int main()
         "host0',arg0='xyz.openbmc_project.State.Host'",
         eventHandler);
 
-    int fd = inotify_init();
-    inotify_add_watch(fd, I2C_DEV_LOCATION,
-                      IN_CREATE | IN_MOVED_TO | IN_DELETE);
-    std::array<char, 4096> readBuffer;
-    std::string pendingBuffer;
-    // monitor for new i2c devices
-    boost::asio::posix::stream_descriptor dirWatch(io, fd);
-    std::function<void(const boost::system::error_code, std::size_t)>
-        watchI2cBusses = [&](const boost::system::error_code& ec,
-                             std::size_t bytes_transferred) {
-            if (ec)
-            {
-                std::cout << "Callback Error " << ec << "\n";
-                return;
-            }
-            pendingBuffer += std::string(readBuffer.data(), bytes_transferred);
-            while (pendingBuffer.size() > sizeof(inotify_event))
-            {
-                const inotify_event* iEvent =
-                    reinterpret_cast<const inotify_event*>(
-                        pendingBuffer.data());
-                switch (iEvent->mask)
-                {
-                    case IN_CREATE:
-                    case IN_MOVED_TO:
-                    case IN_DELETE:
-                        std::string name(iEvent->name);
-                        if (boost::starts_with(name, "i2c"))
-                        {
-                            int bus = busStrToInt(name);
-                            if (bus < 0)
-                            {
-                                std::cerr << "Could not parse bus " << name
-                                          << "\n";
-                                continue;
-                            }
-                            rescanOneBus(busMap, static_cast<uint8_t>(bus),
-                                         dbusInterfaceMap, false);
-                        }
-                }
-
-                pendingBuffer.erase(0, sizeof(inotify_event) + iEvent->len);
-            }
-
-            dirWatch.async_read_some(boost::asio::buffer(readBuffer),
-                                     watchI2cBusses);
-        };
-
-    dirWatch.async_read_some(boost::asio::buffer(readBuffer), watchI2cBusses);
     // run the initial scan
     rescanBusses(busMap, dbusInterfaceMap);
 
diff --git a/src/FruUtils.cpp b/src/FruUtils.cpp
index beeb148..d254f41 100644
--- a/src/FruUtils.cpp
+++ b/src/FruUtils.cpp
@@ -596,127 +596,17 @@ bool validateHeader(const std::array<uint8_t, I2C_SMBUS_BLOCK_MAX>& blockData)
 
 std::vector<uint8_t> readFRUContents(int flag, int file, uint16_t address,
                                      ReadBlockFunc readBlock,
-                                     const std::string& errorHelp)
+                                     const std::string& errorHelp,
+                                     const size_t size)
 {
-    std::array<uint8_t, I2C_SMBUS_BLOCK_MAX> blockData;
-
-    if (readBlock(flag, file, address, 0x0, 0x8, blockData.data()) < 0)
-    {
-        std::cerr << "failed to read " << errorHelp << "\n";
-        return {};
-    }
-
-    // check the header checksum
-    if (!validateHeader(blockData))
-    {
-        if (DEBUG)
-        {
-            std::cerr << "Illegal header " << errorHelp << "\n";
-        }
-
-        return {};
-    }
-
     std::vector<uint8_t> device;
-    device.insert(device.end(), blockData.begin(), blockData.begin() + 8);
-
-    bool hasMultiRecords = false;
-    size_t fruLength = fruBlockSize; // At least FRU header is present
-    unsigned int prevOffset = 0;
-    for (fruAreas area = fruAreas::fruAreaInternal;
-         area <= fruAreas::fruAreaMultirecord; ++area)
-    {
-        // Offset value can be 255.
-        unsigned int areaOffset = device[getHeaderAreaFieldOffset(area)];
-        if (areaOffset == 0)
-        {
-            continue;
-        }
-
-        /* Check for offset order, as per Section 17 of FRU specification, FRU
-         * information areas are required to be in order in FRU data layout
-         * which means all offset value should be in increasing order or can be
-         * 0 if that area is not present
-         */
-        if (areaOffset <= prevOffset)
-        {
-            std::cerr << "Fru area offsets are not in required order as per "
-                         "Section 17 of Fru specification\n";
-            return {};
-        }
-        prevOffset = areaOffset;
-
-        // MultiRecords are different. area is not tracking section, it's
-        // walking the common header.
-        if (area == fruAreas::fruAreaMultirecord)
-        {
-            hasMultiRecords = true;
-            break;
-        }
-
-        areaOffset *= fruBlockSize;
-
-        if (readBlock(flag, file, address, static_cast<uint16_t>(areaOffset),
-                      0x2, blockData.data()) < 0)
-        {
-            std::cerr << "failed to read " << errorHelp << "\n";
-            return {};
-        }
-
-        // Ignore data type (blockData is already unsigned).
-        size_t length = blockData[1] * fruBlockSize;
-        areaOffset += length;
-        fruLength = (areaOffset > fruLength) ? areaOffset : fruLength;
-    }
-
-    if (hasMultiRecords)
-    {
-        // device[area count] is the index to the last area because the 0th
-        // entry is not an offset in the common header.
-        unsigned int areaOffset =
-            device[getHeaderAreaFieldOffset(fruAreas::fruAreaMultirecord)];
-        areaOffset *= fruBlockSize;
-
-        // the multi-area record header is 5 bytes long.
-        constexpr size_t multiRecordHeaderSize = 5;
-        constexpr uint8_t multiRecordEndOfListMask = 0x80;
-
-        // Sanity hard-limit to 64KB.
-        while (areaOffset < std::numeric_limits<uint16_t>::max())
-        {
-            // In multi-area, the area offset points to the 0th record, each
-            // record has 3 bytes of the header we care about.
-            if (readBlock(flag, file, address,
-                          static_cast<uint16_t>(areaOffset), 0x3,
-                          blockData.data()) < 0)
-            {
-                std::cerr << "failed to read " << errorHelp << "\n";
-                return {};
-            }
-
-            // Ok, let's check the record length, which is in bytes (unsigned,
-            // up to 255, so blockData should hold uint8_t not char)
-            size_t recordLength = blockData[2];
-            areaOffset += (recordLength + multiRecordHeaderSize);
-            fruLength = (areaOffset > fruLength) ? areaOffset : fruLength;
 
-            // If this is the end of the list bail.
-            if ((blockData[1] & multiRecordEndOfListMask))
-            {
-                break;
-            }
-        }
-    }
-
-    // You already copied these first 8 bytes (the ipmi fru header size)
-    fruLength -= std::min(fruBlockSize, fruLength);
-
-    int readOffset = fruBlockSize;
-
-    while (fruLength > 0)
+    std::array<uint8_t, I2C_SMBUS_BLOCK_MAX> blockData;
+    size_t readOffset = 0;
+    while (readOffset < size)
     {
         size_t requestLength =
-            std::min(static_cast<size_t>(I2C_SMBUS_BLOCK_MAX), fruLength);
+            std::min(I2C_SMBUS_BLOCK_MAX, static_cast<int>(size - readOffset));
 
         if (readBlock(flag, file, address, static_cast<uint16_t>(readOffset),
                       static_cast<uint8_t>(requestLength),
@@ -730,7 +620,6 @@ std::vector<uint8_t> readFRUContents(int flag, int file, uint16_t address,
                       blockData.begin() + requestLength);
 
         readOffset += requestLength;
-        fruLength -= std::min(requestLength, fruLength);
     }
 
     return device;
-- 
2.28.0

