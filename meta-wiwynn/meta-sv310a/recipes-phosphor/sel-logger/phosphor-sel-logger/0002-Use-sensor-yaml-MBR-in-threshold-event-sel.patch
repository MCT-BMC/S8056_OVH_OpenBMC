From 40ccdcfdce28408a4b67f4706f26b5d1027b2b49 Mon Sep 17 00:00:00 2001
From: Ren_Chen <Ren_Chen@wiwynn.com>
Date: Wed, 16 Jun 2021 15:39:45 +0800
Subject: [PATCH] Use sensor yaml MBR in threshold event sel

---
 include/sensorutils.hpp             | 35 ++++++++++++++++++-----------
 include/threshold_event_monitor.hpp | 18 ++++-----------
 2 files changed, 26 insertions(+), 27 deletions(-)

diff --git a/include/sensorutils.hpp b/include/sensorutils.hpp
index d7fee6d..6e6b753 100644
--- a/include/sensorutils.hpp
+++ b/include/sensorutils.hpp
@@ -18,6 +18,7 @@
 #include <algorithm>
 #include <cmath>
 #include <iostream>
+#include <openbmc/sensor-gen-extra.cpp>
 
 namespace ipmi
 {
@@ -327,23 +328,31 @@ static inline uint8_t
     return static_cast<uint8_t>(clampedValue);
 }
 
-static inline uint8_t getScaledIPMIValue(const double value, const double max,
-                                         const double min)
+static inline uint8_t getScaledIPMIValue(const double value,
+                                         const std::string path)
 {
-    int16_t mValue = 0;
-    int8_t rExp = 0;
-    int16_t bValue = 0;
-    int8_t bExp = 0;
-    bool bSigned = false;
-
-    bool result =
-        getSensorAttributes(max, min, mValue, rExp, bValue, bExp, bSigned);
-    if (!result)
+    auto findSensor = ipmi::sensor::sensorsInfo.find(path);
+    if (findSensor == ipmi::sensor::sensorsInfo.end())
     {
-        throw std::runtime_error("Illegal sensor attributes");
+        throw std::runtime_error("Failed to find sensor information");
     }
 
-    return scaleIPMIValueFromDouble(value, mValue, rExp, bValue, bExp, bSigned);
+    auto sensorInfo = findSensor->second;
+    double scaledValue =
+        value * std::pow(10, sensorInfo.scale - sensorInfo.exponentR);
+
+    double rawData =
+        (scaledValue - sensorInfo.scaledOffset) / sensorInfo.coefficientM;
+    if (rawData > std::numeric_limits<uint8_t>::max())
+    {
+        rawData = std::numeric_limits<uint8_t>::max();
+    }
+
+    if (rawData < std::numeric_limits<uint8_t>::min())
+    {
+        rawData = std::numeric_limits<uint8_t>::min();
+    }
+    return static_cast<uint8_t>(round(rawData));
 }
 
 } // namespace ipmi
diff --git a/include/threshold_event_monitor.hpp b/include/threshold_event_monitor.hpp
index f1df9bd..54d6479 100644
--- a/include/threshold_event_monitor.hpp
+++ b/include/threshold_event_monitor.hpp
@@ -132,22 +132,11 @@ inline static sdbusplus::bus::match::match startThresholdAssertMonitor(
                       << "\n";
             return;
         }
-        double max = 0;
-        auto findMax = sensorValue.find("MaxValue");
-        if (findMax != sensorValue.end())
-        {
-            max = std::visit(ipmi::VariantToDoubleVisitor(), findMax->second);
-        }
-        double min = 0;
-        auto findMin = sensorValue.find("MinValue");
-        if (findMin != sensorValue.end())
-        {
-            min = std::visit(ipmi::VariantToDoubleVisitor(), findMin->second);
-        }
 
         try
         {
-            eventData[1] = ipmi::getScaledIPMIValue(assertValue, max, min);
+            eventData[1] =
+                ipmi::getScaledIPMIValue(assertValue, pathAndEvent.first);
         }
         catch (const std::exception& e)
         {
@@ -194,7 +183,8 @@ inline static sdbusplus::bus::match::match startThresholdAssertMonitor(
         }
         try
         {
-            eventData[2] = ipmi::getScaledIPMIValue(thresholdVal, max, min);
+            eventData[2] =
+                ipmi::getScaledIPMIValue(thresholdVal, pathAndEvent.first);
         }
         catch (const std::exception& e)
         {
-- 
2.32.0

