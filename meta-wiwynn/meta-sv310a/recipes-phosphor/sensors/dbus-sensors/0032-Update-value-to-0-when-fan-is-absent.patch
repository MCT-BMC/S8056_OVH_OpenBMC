From ebb47d9c52ff22c3612c87a20d38692db0d37bfd Mon Sep 17 00:00:00 2001
From: Wayne Tung <Wayne_Tung@wiwynn.com>
Date: Tue, 23 Nov 2021 14:03:13 +0800
Subject: [PATCH 1/2] Update value to 0 when fan is absent

---
 include/TachSensor.hpp |   1 +
 src/TachSensor.cpp     |  36 ++++++------
 src/Utils.cpp          | 122 +++++++++++++++++++++++++----------------
 3 files changed, 95 insertions(+), 64 deletions(-)

diff --git a/include/TachSensor.hpp b/include/TachSensor.hpp
index c524073..4e8a560 100644
--- a/include/TachSensor.hpp
+++ b/include/TachSensor.hpp
@@ -95,6 +95,7 @@ class TachSensor :
     std::shared_ptr<PresenceSensor> presence;
     std::shared_ptr<sdbusplus::asio::dbus_interface> itemIface;
     std::shared_ptr<sdbusplus::asio::dbus_interface> itemAssoc;
+    std::shared_ptr<sdbusplus::asio::dbus_interface> presentIface;
     boost::asio::posix::stream_descriptor inputDev;
     boost::asio::steady_timer waitTimer;
     std::shared_ptr<boost::asio::streambuf> readBuf;
diff --git a/src/TachSensor.cpp b/src/TachSensor.cpp
index a056230..64b8f94 100644
--- a/src/TachSensor.cpp
+++ b/src/TachSensor.cpp
@@ -97,6 +97,11 @@ TachSensor::TachSensor(const std::string& path, const std::string& objectType,
             "Associations",
             std::vector<Association>{{"sensors", "inventory", dbusPath}});
         itemAssoc->initialize();
+
+        presentIface = objectServer.add_interface(
+            dbusPath, "xyz.openbmc_project.Inventory.Item");
+        presentIface->register_property("Present", true);
+        presentIface->initialize();
     }
 
     if (sensorType == "pwm")
@@ -123,6 +128,7 @@ TachSensor::~TachSensor()
     objServer.remove_interface(association);
     objServer.remove_interface(itemIface);
     objServer.remove_interface(itemAssoc);
+    objServer.remove_interface(presentIface);
 }
 
 void TachSensor::hardOffInCaceSoftOffFail(
@@ -364,11 +370,10 @@ void TachSensor::handleResponse(const boost::system::error_code& err)
     {
         if (!presence->getValue())
         {
-            markAvailable(false);
             missing = true;
-            pollTime = sensorFailedPollTimeMs;
         }
         itemIface->set_property("Present", !missing);
+        presentIface->set_property("Present", !missing);
     }
 
     if (!fanPowerEnable)
@@ -415,6 +420,10 @@ void TachSensor::handleResponse(const boost::system::error_code& err)
                 pollTime = sensorFailedPollTimeMs;
             }
         }
+        else
+        {
+            updateValue(0);
+        }
 
         if (((errCount >= errorThreshold) || missing) && !thresholds.empty())
         {
@@ -569,26 +578,19 @@ void PresenceSensor::read(void)
     gpioLine.event_read();
     int currentStatus = gpioLine.get_value();
     // Read is invoked when an edge event is detected by monitorPresence
-    if (currentStatus)
+    if ((currentStatus == 1) && !status)
     {
-        // To prevent from logging lower critical threshold
-        delayTimer.expires_after(std::chrono::seconds(2));
-        delayTimer.async_wait(
-            [this, currentStatus](const boost::system::error_code& ec) {
-                if (ec == boost::asio::error::operation_aborted)
-                {
-                    return; // we're being canceled
-                }
-
-                status = currentStatus;
-            });
-
         logFanInserted(name, selSensorName);
+        status = currentStatus;
     }
-    else
+    else if ((currentStatus == 0) && status)
     {
-        status = currentStatus;
         logFanRemoved(name, selSensorName);
+        status = currentStatus;
+    }
+    else
+    {
+        std::cerr << "Unknow status("<< status << "), currentStatus(" << currentStatus << ") on presence sensor" << name << " \n";
     }
 }
 
diff --git a/src/Utils.cpp b/src/Utils.cpp
index d4f4610..cd8cae2 100644
--- a/src/Utils.cpp
+++ b/src/Utils.cpp
@@ -247,65 +247,93 @@ static void
     getPowerStatus(const std::shared_ptr<sdbusplus::asio::connection>& conn,
                    size_t retries = 2)
 {
-    conn->async_method_call(
-        [conn, retries](boost::system::error_code ec,
-                        const std::variant<bool>& state) {
-            if (ec)
-            {
-                if (retries)
+    auto message = conn->new_method_call(
+        gpio::busname, gpio::path, properties::interface, properties::get);
+    message.append(gpio::interface, gpio::pgood);
+    try
+    {
+        auto reply = conn->call(message);
+        std::variant<bool> state;
+        reply.read(state);
+        powerStatusOn = std::get<bool>(state);
+    }
+    catch (const sdbusplus::exception_t& e)
+    {
+        conn->async_method_call(
+            [conn, retries](boost::system::error_code ec,
+                            const std::variant<bool>& state) {
+                if (ec)
                 {
-                    auto timer = std::make_shared<boost::asio::steady_timer>(
-                        conn->get_io_context());
-                    timer->expires_after(std::chrono::seconds(15));
-                    timer->async_wait(
-                        [timer, conn, retries](boost::system::error_code) {
-                            getPowerStatus(conn, retries - 1);
-                        });
+                    if (retries)
+                    {
+                        auto timer =
+                            std::make_shared<boost::asio::steady_timer>(
+                                conn->get_io_context());
+                        timer->expires_after(std::chrono::seconds(15));
+                        timer->async_wait(
+                            [timer, conn, retries](boost::system::error_code) {
+                                getPowerStatus(conn, retries - 1);
+                            });
+                        return;
+                    }
+
+                    // we commonly come up before power control, we'll capture
+                    // the property change later
+                    std::cerr << "error getting power status " << ec.message()
+                              << "\n";
                     return;
                 }
-
-                // we commonly come up before power control, we'll capture the
-                // property change later
-                std::cerr << "error getting power status " << ec.message()
-                          << "\n";
-                return;
-            }
-            powerStatusOn = std::get<bool>(state);
-        },
-        gpio::busname, gpio::path, properties::interface, properties::get,
-        gpio::interface, gpio::pgood);
+                powerStatusOn = std::get<bool>(state);
+            },
+            gpio::busname, gpio::path, properties::interface, properties::get,
+            gpio::interface, gpio::pgood);
+    }
 }
 
 static void
     getPostStatus(const std::shared_ptr<sdbusplus::asio::connection>& conn,
                   size_t retries = 2)
 {
-    conn->async_method_call(
-        [conn, retries](boost::system::error_code ec,
-                        const std::variant<bool>& state) {
-            if (ec)
-            {
-                if (retries)
+    auto message = conn->new_method_call(
+        gpio::busname, gpio::path, properties::interface, properties::get);
+    message.append(gpio::interface, gpio::postComplete);
+    try
+    {
+        auto reply = conn->call(message);
+        std::variant<bool> state;
+        reply.read(state);
+        biosHasPost = !std::get<bool>(state);
+    }
+    catch (const sdbusplus::exception_t& e)
+    {
+        conn->async_method_call(
+            [conn, retries](boost::system::error_code ec,
+                            const std::variant<bool>& state) {
+                if (ec)
                 {
-                    auto timer = std::make_shared<boost::asio::steady_timer>(
-                        conn->get_io_context());
-                    timer->expires_after(std::chrono::seconds(15));
-                    timer->async_wait(
-                        [timer, conn, retries](boost::system::error_code) {
-                            getPostStatus(conn, retries - 1);
-                        });
+                    if (retries)
+                    {
+                        auto timer =
+                            std::make_shared<boost::asio::steady_timer>(
+                                conn->get_io_context());
+                        timer->expires_after(std::chrono::seconds(15));
+                        timer->async_wait(
+                            [timer, conn, retries](boost::system::error_code) {
+                                getPostStatus(conn, retries - 1);
+                            });
+                        return;
+                    }
+                    // we commonly come up before power control, we'll capture
+                    // the property change later
+                    std::cerr << "error getting post status " << ec.message()
+                              << "\n";
                     return;
                 }
-                // we commonly come up before power control, we'll capture the
-                // property change later
-                std::cerr << "error getting post status " << ec.message()
-                          << "\n";
-                return;
-            }
-            biosHasPost = !std::get<bool>(state);
-        },
-        gpio::busname, gpio::path, properties::interface, properties::get,
-        gpio::interface, gpio::postComplete);
+                biosHasPost = !std::get<bool>(state);
+            },
+            gpio::busname, gpio::path, properties::interface, properties::get,
+            gpio::interface, gpio::postComplete);
+    }
 }
 
 void setupPowerMatch(const std::shared_ptr<sdbusplus::asio::connection>& conn)
-- 
2.32.0

