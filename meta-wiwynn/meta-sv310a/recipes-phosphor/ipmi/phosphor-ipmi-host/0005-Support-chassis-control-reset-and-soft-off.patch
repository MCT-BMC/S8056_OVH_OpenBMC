From aa3bf2d2777e697d763b99e30b03920662fbb93d Mon Sep 17 00:00:00 2001
From: Ren_Chen <Ren_Chen@wiwynn.com>
Date: Thu, 29 Jul 2021 08:24:53 +0800
Subject: [PATCH] Support chassis control reset and soft off

---
 chassishandler.cpp | 83 +++++++++++++++++++++-------------------------
 1 file changed, 38 insertions(+), 45 deletions(-)

diff --git a/chassishandler.cpp b/chassishandler.cpp
index a4e98f8..5578560 100644
--- a/chassishandler.cpp
+++ b/chassishandler.cpp
@@ -108,13 +108,13 @@ const static constexpr char chassisBridgeDevAddrProp[] = "BridgeDeviceAddress";
 static constexpr uint8_t chassisCapFlagMask = 0x0f;
 static constexpr uint8_t chassisCapAddrMask = 0xfe;
 static constexpr const char* powerButtonIntf =
-    "xyz.openbmc_project.Chassis.Buttons.Power";
+    "xyz.openbmc_project.ButtonHandler.Buttons.PWRBTN";
 static constexpr const char* powerButtonPath =
-    "/xyz/openbmc_project/Chassis/Buttons/Power0";
+    "/xyz/openbmc_project/ButtonHandler/Buttons/PWRBTN";
 static constexpr const char* resetButtonIntf =
-    "xyz.openbmc_project.Chassis.Buttons.Reset";
+    "xyz.openbmc_project.ButtonHandler.Buttons.RSTBTN";
 static constexpr const char* resetButtonPath =
-    "/xyz/openbmc_project/Chassis/Buttons/Reset0";
+    "/xyz/openbmc_project/ButtonHandler/Buttons/RSTBTN";
 
 // Phosphor Host State manager
 namespace State = sdbusplus::xyz::openbmc_project::State::server;
@@ -1144,14 +1144,13 @@ ipmi::RspType<bool,    // Power is on
         resetButtonDisabled = *resetButtonReading;
     }
 
-    bool powerDownAcFailed = power_policy::getACFailStatus();
-
     // This response has a lot of hard-coded, unsupported fields
     // They are set to false or 0
     constexpr bool powerOverload = false;
     constexpr bool chassisInterlock = false;
     constexpr bool powerFault = false;
     constexpr bool powerControlFault = false;
+    constexpr bool powerDownAcFailed = false;
     constexpr bool powerDownOverload = false;
     constexpr bool powerDownInterlock = false;
     constexpr bool powerDownPowerFault = false;
@@ -1374,65 +1373,59 @@ void indicate_no_softoff_needed()
  */
 ipmi::RspType<> ipmiChassisControl(uint8_t chassisControl)
 {
+    std::optional<bool> powerGood = power_policy::getPowerStatus();
+    if (!powerGood)
+    {
+        log<level::ERR>("Failed to get powergood state while chassis control");
+    }
+
     int rc = 0;
     switch (chassisControl)
     {
         case CMD_POWER_ON:
+            if (powerGood && (*powerGood == true))
+            {
+                return ipmi::responseCommandNotAvailable();
+            }
+
             rc = initiate_state_transition(State::Host::Transition::On);
             break;
         case CMD_POWER_OFF:
-            // This path would be hit in 2 conditions.
-            // 1: When user asks for power off using ipmi chassis command 0x04
-            // 2: Host asking for power off post shutting down.
-
-            // If it's a host requested power off, then need to nudge Softoff
-            // application that it needs to stop the watchdog timer if running.
-            // If it is a user requested power off, then this is not really
-            // needed. But then we need to differentiate between user and host
-            // calling this same command
-
-            // For now, we are going ahead with trying to nudge the soft off and
-            // interpret the failure to do so as a non softoff case
-            rc = stop_soft_off_timer();
-
-            // Only request the Off transition if the soft power off
-            // application is not running
-            if (rc < 0)
+            if (powerGood && (*powerGood == false))
             {
-                // First create a file to indicate to the soft off application
-                // that it should not run. Not doing this will result in State
-                // manager doing a default soft power off when asked for power
-                // off.
-                indicate_no_softoff_needed();
-
-                // Now request the shutdown
-                rc = initiate_state_transition(State::Host::Transition::Off);
+                return ipmi::responseCommandNotAvailable();
             }
-            else
+
+            rc = initiate_state_transition(State::Host::Transition::Off);
+            break;
+
+        case CMD_HARD_RESET:
+            if (powerGood && (*powerGood == false))
             {
                 log<level::INFO>("Soft off is running, so let shutdown target "
                                  "stop the host");
+                return ipmi::responseCommandNotAvailable();
             }
-            break;
 
-        case CMD_HARD_RESET:
+            rc = initiate_state_transition(State::Host::Transition::ForceWarmReboot);
+            break;
         case CMD_POWER_CYCLE:
-            // SPEC has a section that says certain implementations can trigger
-            // PowerOn if power is Off when a command to power cycle is
-            // requested
-
-            // First create a file to indicate to the soft off application
-            // that it should not run since this is a direct user initiated
-            // power reboot request (i.e. a reboot request that is not
-            // originating via a soft power off SMS request)
-            indicate_no_softoff_needed();
+            if (powerGood && (*powerGood == false))
+            {
+                return ipmi::responseCommandNotAvailable();
+            }
 
             rc = initiate_state_transition(State::Host::Transition::Reboot);
+
             break;
 
         case CMD_SOFT_OFF_VIA_OVER_TEMP:
-            // Request Host State Manager to do a soft power off
-            rc = initiate_state_transition(State::Host::Transition::Off);
+            if (powerGood && (*powerGood == false))
+            {
+                return ipmi::responseCommandNotAvailable();
+            }
+
+            rc = initiate_state_transition(State::Host::Transition::SoftOff);
             break;
 
         case CMD_PULSE_DIAGNOSTIC_INTR:
-- 
2.32.0

