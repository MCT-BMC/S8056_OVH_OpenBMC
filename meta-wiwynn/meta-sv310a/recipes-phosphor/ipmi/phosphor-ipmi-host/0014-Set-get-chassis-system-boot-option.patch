From 5da519314c4f58f7b7e837ca17f9b488f70378e6 Mon Sep 17 00:00:00 2001
From: Wayne Tung <Wayne_Tung@wiwynn.com>
Date: Wed, 11 Aug 2021 14:11:01 +0800
Subject: [PATCH] Set get chassis system boot option

---
 chassishandler.cpp | 136 ++++++++++++++++++++++++++++++++++++++++++---
 chassishandler.hpp |   5 +-
 2 files changed, 131 insertions(+), 10 deletions(-)

diff --git a/chassishandler.cpp b/chassishandler.cpp
index 402765c..6457105 100644
--- a/chassishandler.cpp
+++ b/chassishandler.cpp
@@ -1394,6 +1394,27 @@ void indicate_no_softoff_needed()
     std::ofstream(path.c_str());
 }
 
+static constexpr auto bootOptionService = "xyz.openbmc_project.BootOption";
+static constexpr auto bootOptionPath = "/xyz/openbmc_project/control/boot";
+static constexpr auto bootOptionValidIntf = "xyz.openbmc_project.Control.Valid";
+
+static void restartBootFlagsValidTimer()
+{
+    try
+    {
+        sdbusplus::bus::bus bus(ipmid_get_sd_bus_connection());
+        auto msg =
+            bus.new_method_call(bootOptionService, bootOptionPath,
+                                bootOptionValidIntf, "RestartValidTimer");
+        bus.call_noreply(msg);
+    }
+    catch (const std::exception& e)
+    {
+        log<level::ERR>("Failed to restart boot flags valid timer",
+                        entry("ERROR=%s", e.what()));
+    }
+}
+
 /** @brief Implementation of chassis control command
  *
  *  @param - chassisControl command byte
@@ -1402,6 +1423,8 @@ void indicate_no_softoff_needed()
  */
 ipmi::RspType<> ipmiChassisControl(uint8_t chassisControl)
 {
+    restartBootFlagsValidTimer();
+
     std::optional<bool> powerGood = power_policy::getPowerStatus();
     if (!powerGood)
     {
@@ -1737,6 +1760,12 @@ static constexpr uint8_t setComplete = 0x0;
 static constexpr uint8_t setInProgress = 0x1;
 static uint8_t transferStatus = setComplete;
 
+static uint5_t bootFlagValidBitClr = 0;
+static constexpr uint8_t dontClearPEF = 0x10;
+
+static bool biosCmosClear = false;
+static uint5_t bootInitiatorAcknowledgeData = 0;
+
 /** @brief implements the Get Chassis system boot option
  *  @param ctx - context pointer
  *  @param bootOptionParameter   - boot option parameter selector
@@ -1784,8 +1813,32 @@ ipmi::RspType<ipmi::message::Payload>
         BootOptionParameter::bootInfo)
     {
         constexpr uint8_t writeMask = 0;
-        constexpr uint8_t bootInfoAck = 0;
-        response.pack(bootOptionParameter, writeMask, bootInfoAck);
+        response.pack(bootOptionParameter, reserved1, writeMask,
+                      bootInitiatorAcknowledgeData, uint3_t{});
+        return ipmi::responseSuccess(std::move(response));
+    }
+
+    if (types::enum_cast<BootOptionParameter>(bootOptionParameter) ==
+        BootOptionParameter::bootFlagValidClr)
+    {
+        uint8_t bootFlagValidBitClr = 0;
+        try
+        {
+            sdbusplus::bus::bus bus(ipmid_get_sd_bus_connection());
+            auto variant = ipmi::getDbusProperty(
+                bus, bootOptionService, bootOptionPath, bootOptionValidIntf,
+                "BootFlagValidBitClearing");
+            bootFlagValidBitClr = std::get<uint8_t>(variant);
+        }
+        catch (const std::exception& e)
+        {
+            log<level::ERR>("Failed to fetch BootFlagValidBitClearing property",
+                            entry("ERROR=%s", e.what()));
+            return ipmi::responseUnspecifiedError();
+        }
+
+        response.pack(bootOptionParameter, reserved1,
+                      static_cast<uint5_t>(bootFlagValidBitClr), uint3_t{});
         return ipmi::responseSuccess(std::move(response));
     }
 
@@ -1883,12 +1936,29 @@ ipmi::RspType<ipmi::message::Payload>
             auto oneTimeEnabled =
                 std::get<settings::boot::OneTimeEnabled>(bootSetting);
             uint1_t permanent = oneTimeEnabled ? 0 : 1;
-            uint1_t validFlag = 1;
+
+            bool bootFlagsValid = false;
+            try
+            {
+                sdbusplus::bus::bus bus(ipmid_get_sd_bus_connection());
+                auto variant = ipmi::getDbusProperty(
+                    bus, bootOptionService, bootOptionPath, bootOptionValidIntf,
+                    "BootFlagsValid");
+                bootFlagsValid = std::get<bool>(variant);
+            }
+            catch (const std::exception& e)
+            {
+                log<level::ERR>("Failed to fetch BootFlagsValid property",
+                                entry("ERROR=%s", e.what()));
+                return ipmi::responseUnspecifiedError();
+            }
 
             response.pack(bootOptionParameter, reserved1, uint5_t{},
                           uint1_t{biosBootType}, uint1_t{permanent},
-                          uint1_t{validFlag}, uint2_t{}, uint4_t{bootOption},
-                          uint2_t{}, uint8_t{}, uint8_t{}, uint8_t{});
+                          uint1_t{bootFlagsValid}, uint2_t{},
+                          uint4_t{bootOption}, uint1_t{}, biosCmosClear,
+                          uint8_t{}, uint8_t{}, uint8_t{});
+
             return ipmi::responseSuccess(std::move(response));
         }
         catch (InternalFailure& e)
@@ -2099,6 +2169,22 @@ ipmi::RspType<> ipmiChassisSetSysBootOptions(ipmi::Context::ptr ctx,
                 "flag parameters");
             return ipmi::responseUnspecifiedError();
         }
+
+        biosCmosClear = cmosClear;
+
+        try
+        {
+            sdbusplus::bus::bus bus(ipmid_get_sd_bus_connection());
+            ipmi::setDbusProperty(bus, bootOptionService, bootOptionPath,
+                                  bootOptionValidIntf, "BootFlagsValid",
+                                  validFlag);
+        }
+        catch (const std::exception& e)
+        {
+            log<level::ERR>("Failed to set BootFlagsValid property",
+                            entry("ERROR=%s", e.what()));
+            return ipmi::responseUnspecifiedError();
+        }
     }
     else if (types::enum_cast<BootOptionParameter>(parameterSelector) ==
              BootOptionParameter::bootInfo)
@@ -2116,15 +2202,47 @@ ipmi::RspType<> ipmiChassisSetSysBootOptions(ipmi::Context::ptr ctx,
         {
             return ipmi::responseInvalidFieldRequest();
         }
-        // (ccSuccess). There is no implementation in OpenBMC for this
-        // parameter. This is added to support the ipmitool command `chassis
-        // bootdev` which sends set on parameter #4, before setting the boot
-        // flags.
+
+        bootInitiatorAcknowledgeData = bootInitiatorAckData;
         log<level::INFO>("ipmiChassisSetSysBootOptions: bootInfo parameter set "
                          "successfully");
         data.trailingOk = true;
         return ipmi::responseSuccess();
     }
+    else if (types::enum_cast<BootOptionParameter>(parameterSelector) ==
+             BootOptionParameter::bootFlagValidClr)
+    {
+        uint5_t bootFlagValidBitClearing;
+        uint3_t rsvd;
+
+        if ((data.unpack(bootFlagValidBitClearing, rsvd) != 0) ||
+            !data.fullyUnpacked())
+        {
+            return ipmi::responseReqDataLenInvalid();
+        }
+        // PEF is not supported
+        if (rsvd || (bootFlagValidBitClearing & dontClearPEF))
+        {
+            return ipmi::responseInvalidFieldRequest();
+        }
+
+        try
+        {
+            sdbusplus::bus::bus bus(ipmid_get_sd_bus_connection());
+            ipmi::setDbusProperty(
+                bus, bootOptionService, bootOptionPath, bootOptionValidIntf,
+                "BootFlagValidBitClearing",
+                static_cast<uint8_t>(bootFlagValidBitClearing));
+        }
+        catch (const std::exception& e)
+        {
+            log<level::ERR>("Failed to set BootFlagValidBitClearing property",
+                            entry("ERROR=%s", e.what()));
+            return ipmi::responseUnspecifiedError();
+        }
+
+        return ipmi::responseSuccess();
+    }
     else
     {
         if ((parameterSelector >= static_cast<uint7_t>(oemParmStart)) &&
diff --git a/chassishandler.hpp b/chassishandler.hpp
index 4d7d450..2354614 100644
--- a/chassishandler.hpp
+++ b/chassishandler.hpp
@@ -48,6 +48,7 @@ enum ipmi_chassis_control_cmds : uint8_t
 enum class BootOptionParameter : size_t
 {
     setInProgress = 0x0,
+    bootFlagValidClr = 0x3,
     bootInfo = 0x4,
     bootFlags = 0x5,
     opalNetworkSettings = 0x61
@@ -55,7 +56,9 @@ enum class BootOptionParameter : size_t
 
 enum class BootOptionResponseSize : size_t
 {
-    setInProgress = 3,
+    setInProgress = 1,
+    bootFlagValidClr = 1,
+    bootInfo = 2,
     bootFlags = 5,
     opalNetworkSettings = 50
 };
-- 
2.32.0

